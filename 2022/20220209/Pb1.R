setwd("C:/Users/Giuseppe/Documents/.magistrale/secondo anno/AppStat/Exams/2022/20220209/20220209")
data <- read.table("nutrients.txt",header = T)

head(data)
dim(data)

n <- dim(data)[1]
p <- dim(data)[2]


# see if the variances are different
{
  par(mfrow = c(1,1))
  boxplot(data, las = 2, col = 'gold')
  ## centred boxplot
  boxplot(scale(x = data, center = T, scale = F), las = 2, col = 'gold')
}
# the variability kcal of nutrients represented in the dataset is higher than other nutrients
# Vaeiables must be standardized
{
  data.sd <- scale(data)
  data.sd <- data.frame(data.sd)
  head(data.sd)
  # Boxplot
  par(mfrow = c(1, 1))
  boxplot(data.sd, las = 2, col = 'gold')
  # now every box has similar height
  # you can see in the next plot how every feature has variance 1
  barplot(sapply(data.sd, sd)^2, las = 2, main = 'Standardized Variables', ylim = c(0, 7),
          ylab = 'Variances')
}

# PCA
{ 
  pc.data <- princomp(data.sd, scores = T)
  pc.data
  summary(pc.data)
}

# Loadings
{
  load.data <- pc.data$loadings
  load.data[,1]
  
  
  
}
# Graphical representation of loadings of the first 3 PC
par(mar = c(2,2,2,1), mfrow=c(3,1))
for(i in 1:3)barplot(load.data[,i], ylim = c(-1, 1), main=paste('Loadings PC ',i,sep=''))
par( mfrow=c(1,1))

biplot(pc.data)






# an alternative to elbow method possible when standardized
{
  # select up until they are greater than 1 in this plot
  # this because all features were explaining 1 variability (since standardized)
  # -> I'm doing better with PC than with original variables 
  par(mfrow = c(1, 1))
  plot(pc.data, las = 2, main = 'Principal Components', ylim = c(0, 7))
  abline(h=1, col = "blue", lty = 2)
}

# Elbow method
{
  par(mfrow = c(1, 1))
  plot(cumsum(pc.data$sde^2) / sum(pc.data$sde^2), type = 'b', axes = TRUE, 
       xlab = 'Number of components', ylab = 'Contribution to the total variance', ylim = c(0, 1))
  abline(h = 1, col = 'blue')
  abline(h = 0.8, lty = 2, col = 'blue')  
}

# i'd use first 2 components, explaining 77% of the total variability

pc.data$sd^2/sum(pc.data$sd^2)
cumsum(pc.data$sd^2)[1:2]/sum(pc.data$sd^2)


# e)
# Project a new entry to the space generated by the first 2 component:
{
  new_entry <- data.frame(
    Energy_kcal  = 400,
    Protein_g  = 9.,
    Fat_g = 5,
    Carb_g  = 100,
    Sugar_g = 30,
    Fiber_g = 4
    # ... 
  )
  x.mean = colMeans(data)
  x.cov = sapply(data, FUN = sd)
  
  new_entry = (new_entry - x.mean)/ x.cov
  
  new_entry_projected <- predict(pc.data, newdata = new_entry)[, 1:2]  
}
scores.data <- pc.data$scores
new_entry_projected
plot(scores.data[, 1:2], pch=19)
points(new_entry_projected[1],new_entry_projected[2], col='red', pch=19)





